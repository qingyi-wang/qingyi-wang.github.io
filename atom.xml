<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Imaging Home</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-04-12T05:24:01.819Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Dc.Wang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ALTERA 关于 FPGA 设计流程的阐述（个人认为 XIlinx 的设计流程也是适用的）</title>
    <link href="http://yoursite.com/2017/04/12/%E5%85%B3%E4%BA%8E%20Testbench%20%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93_2017%E5%B9%B44%E6%9C%8812%E6%97%A5/"/>
    <id>http://yoursite.com/2017/04/12/关于 Testbench 的一些总结_2017年4月12日/</id>
    <published>2017-04-12T05:05:18.519Z</published>
    <updated>2017-04-12T05:24:01.819Z</updated>
    
    <content type="html"><![CDATA[<p>　　主要是借鉴 CRAZY BINGO 的 demo，非常感谢他，让我学习 FPGA 的道路不会那么艰难。　　–Dc.Wang</p>
<h2 id="FPGA-设计流程"><a href="#FPGA-设计流程" class="headerlink" title="FPGA 设计流程"></a>FPGA 设计流程</h2><p>　　FPGA 设计流程的主要步骤如下：<br>　　1. 设计源于 Idea，没有一个设计的框架，不能盲目地进行开发。因此第一步是设计的来源。<br>　　2. 利用 Verilog HDL 或原理图、IP 核等方式设计电路图。<br>　　3. 利用 Quartus II 进行电路综合。<br>　　4. 利用 Quartus II 进行逻辑电路的布局布线。<br>　　5. 适用第三方软件进行仿真测试、逻辑验证等。<br>　　6. 固化 FPGA/CPLD<br>　　一个完整的设计，除了文档的规范，大部分时间都在仿真做仿真验证，即 Testbench。而不是 RTL 电路测试。作为一个可靠性设计， Testbench 不可或缺地成为一个验证高级语言（High_Level Language, HLL）设计的标准方法。而 Testbench 充当的角色，便是设计的激励。将激励输入设计中，通过 Modelsim 观察输出波形，来验证时序设计的正确与否，是最基本的流程。  </p>
<h2 id="Testbench-代码设计风格"><a href="#Testbench-代码设计风格" class="headerlink" title="Testbench 代码设计风格"></a>Testbench 代码设计风格</h2><p>　　Testbench 作为 Modelsim 的激励文件，也是自成体系的，同样具有规范化设计，需要完美的风格及苛刻的结构。<br>　　1. <strong>Testbench 文件头编写规范</strong><br>　　与 Verilog HDL 完全一样，这部分只是 Coding 的基本规范，具体格式参照 Veirlog 代码风格。</p>
<p>　　2. <strong>Module 列表编写规范</strong><br>　　Module 列表编写规范如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">`timescale 1ns/1ns</div><div class="line">module Testbench_tb;</div><div class="line">wire [7:0] led_data;  //data test</div><div class="line">endmodule</div></pre></td></tr></table></figure>
<p>　　如上所述，Testbench 不同于 Verilog HDL 的地方是没有输入/输出信号的定义，每一个激励都是在当前文件中生成的，唯一与外界通信的 wire 是直接连接到需要测试的 Module 上的。而 Testbench 中的 Module 信号类表是当前文件需要输出的信号。在这里，顶层文件定义了 led_data 为输出信号，便于在 Modelsim 中添加并且观察波形。此外，还应遵循一下规范:<br>　　(1) Module 前必须写 `timescale 1ns/1ns;<br>　　(2) Module 后紧跟 Testbench 需要输出的信号（当模块多时，紧跟当前 module）;<br>　　(3) 相关信号必须写在一起，并且有注释。<br>　　备注：虽然不添加 wire 信号也无所谓，可以直接在波形中添加待测试 Module 的信号，但这样 wire，设计脚本更加清晰。</p>
<p>　　3. <strong>时钟发生器编写规范</strong><br>　　时钟发生器编写规范如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">//---------------------------------------------------------------------------</div><div class="line">// clock generate module</div><div class="line">reg clk;</div><div class="line">reg rst_n;</div><div class="line">localparam RERIOD = 20; // 100MHz</div><div class="line">initial </div><div class="line">	begin</div><div class="line">		clk = 0;</div><div class="line">		forever #(PERIOD)</div><div class="line">		clk = ~clk; </div><div class="line">	end</div><div class="line"></div><div class="line">task task_reset;</div><div class="line">	begin</div><div class="line">		rst_n = 0;</div><div class="line">		repeat(2) @(negedge clk);</div><div class="line">		rst_n = 0;	</div><div class="line">	end</div><div class="line">endtask</div></pre></td></tr></table></figure>
<p>　　这一部分时每一个　Testbench 都必须包含的内容，主要用来生成待测 Module 的激励时钟及复位信号。clk 通过 initial 实现 PERIOD2 的翻转，而 rst_n 通常置前 2 个时钟为低电平，之后为高电平的 Task （任务）实现。理解 Testbench 可以完全按照 C 语言的思路，Testbench 完全是线程的设计，当然也可以实现 always 类的并行设计，但是任务的调用必须是线程的。Testbench 通过任务的调用来实现激励的产生，必须而且只能有一次定义：<br>　　(1) 该模块放在 Testbench 的 Module 之后，必须而且只能有一次定义；<br>　　(2) 时钟可通过 PERIOD 的宏定义去修改；<br>　　(3) 类似时钟的生成可参考该部分的 clk 设计；</p>
<p>　　4. <strong>模块的例化编写规范</strong><br>　　这部分与 Verilog HDL 的设计规范完全相同，直接调用需要测试的模块，通过例化完成线路的连接，作为 Modelsim 分析的目标电路，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">//------------------------------------------------------------------------------</div><div class="line">//  the target component instantiation</div><div class="line">reg spi_cs;</div><div class="line">reg spi_sck;</div><div class="line">reg spi_mosi;</div><div class="line"></div><div class="line">//------------------------------------------------------------------------------</div><div class="line">// SPI Data receive from MCU</div><div class="line">wire         rxd_flag;</div><div class="line">wire  [7:0]  rxd_data;</div><div class="line">spi_receiver u_spi_receiver</div><div class="line">(</div><div class="line">	// global clock</div><div class="line">	.clk           (clk_ref)  // 100MHz</div><div class="line">	.rst_n         (rst_n)    // global reset</div><div class="line"></div><div class="line">	// mcu spi interface</div><div class="line">	.spi_cs        (spi_cs)   // Chip select enable, default:L</div><div class="line">	.spi_sck       (spi_sck)  // Data transfer clock</div><div class="line">	.spi_mosi      (spi_mosi) // Master output and slave input</div><div class="line">//  .spi_miso      (spi_miso) // Master input and slave output</div><div class="line">	</div><div class="line">	// user interface</div><div class="line">	.rxd_flag      (rxd_flag) // spi receive complete flag</div><div class="line">	.rxd_data      (rxd_data) // spi receive data</div><div class="line">)</div></pre></td></tr></table></figure>
<p>　　该模块简介明了，唯一的规范便是保证所有输出信号都需要初始化，否则不能正常仿真。</p>
<p>　　5. <strong>系统的初始化编写规范</strong><br>　　Testbench 可以通过设计 Task 功能来实现任务的模块化编写及调用，而这些部分的目的就是为了在最后生成待测文件的测试激励，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//------------------------------------------------------------------------------</div><div class="line">// testbench of the RTL</div><div class="line">initial</div><div class="line">	begin 	</div><div class="line">		task_sysinit;</div><div class="line">		task_reset;</div><div class="line"></div><div class="line">		repeat(5) @(posedge clk);</div><div class="line">		task_muc_spi_txd(8&apos;h95);</div><div class="line">		</div><div class="line">		repeat(5) @(posedge clk);</div><div class="line">		task_muc_spi_txd(8&apos;hbe);</div><div class="line">	end</div></pre></td></tr></table></figure>
<p>　　在测试激励生成的代码编写规范中，必须遵循以下几点：<br>　　(1) 采用 initial 结构，生成现成的激励；<br>　　(2) 采用先进系统进行系统初始化，接着进行复位，然后才能进行其他的激励；<br>　　(3) 为了代码的可读性和可移植性，激励都通过 Task 去编写及调用，保证代码清晰，便于修改；<br>　　(4) 同一功能的激励规划放在一起，并且需要必要的注释。<br>　　有人说：“掌握了　ＦＰＧＡ，你便掌握了未来。”，但事实上是：“掌握了 DUT，你便掌握了未来”。 DUT设计流程是 FPGA 最基本的设计思路。很多人都说想学好 FPGA 很难，而笔者认为 FPGA 难就难在设计流程的复杂、时序电路设计的精要，以及并行思维的设计能力。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　主要是借鉴 CRAZY BINGO 的 demo，非常感谢他，让我学习 FPGA 的道路不会那么艰难。　　–Dc.Wang&lt;/p&gt;
&lt;h2 id=&quot;FPGA-设计流程&quot;&gt;&lt;a href=&quot;#FPGA-设计流程&quot; class=&quot;headerlink&quot; title=&quot;FPG
    
    </summary>
    
    
      <category term="FPGA" scheme="http://yoursite.com/tags/FPGA/"/>
    
  </entry>
  
  <entry>
    <title>FPGA_HDMI demo 总结</title>
    <link href="http://yoursite.com/2017/04/08/FPGA_HDMI_demo_2017%E5%B9%B44%E6%9C%888%E6%97%A5/"/>
    <id>http://yoursite.com/2017/04/08/FPGA_HDMI_demo_2017年4月8日/</id>
    <published>2017-04-08T04:30:38.836Z</published>
    <updated>2017-04-12T05:21:21.255Z</updated>
    
    <content type="html"><![CDATA[<p>　　写在前面：耗时两周，终于算是搞定了第一个自己做的关于 HDMI 显示 rom 图片的小项目，过程艰辛（周围没有做这方面的同学），有好几次都想放弃，但最终还是坚持下来啦。啊哈哈，为自己点个赞。下面把我的经历写下来，希望对以后学习的同学有一些帮助。</p>
<h2 id="一-做这个的原因"><a href="#一-做这个的原因" class="headerlink" title="一.做这个的原因"></a>一.做这个的原因</h2><p>　　开始写了哈。这也算是我的第一个 MD demo，可谓是有些小兴奋。<br>　　最近在找实习，找到了一家实习公司，还愿意来培养我，给我安排一些任务来做，感觉还是蛮刺激的。现在主要做的是特征 Fast 点算法的移植。然后最开始肯定是平台的搭建呀，所以就有了想做一个 HDMI 显示 rom 图片这样小项目的目标。目的也比较单纯，对于我这样一个纯小白来说还是有很大的锻炼机会，权当学习了。不过到目前为止，我也不敢说我对与显示方面有比较深的理解，只是算是入门吧。</p>
<h2 id="二-开始的理解及解决方法"><a href="#二-开始的理解及解决方法" class="headerlink" title="二.开始的理解及解决方法"></a>二.开始的理解及解决方法</h2><p>###1. <strong>对方案毫无头绪</strong><br>　　最开始的思路是想从 zynq ip 核层次做这个东西，后在参考了米联客他们写的 demo 后发现结合 sdk 做需要一的基础。为使自己更加稳步地提高，我决定从最底层地 Verilog HDL 语言设计开始。最后定下的方案便是设计驱动电路驱动 HDMI，然后基于这个基础上加上 rom 储存的二进制图片文件进行显示。大概的设计流程是这样，但过程还是比较艰辛的。</p>
<p>###2. <strong>HDMI 驱动电路的实现</strong><br>　　在写驱动电路之前，我其实也是最开始比较焦躁的，希望一下子可以把这件事情做完。所以我最开始的想法是想把别人的 demo 拿来直接用，但是网上没有关于 zynq 这块板子上用 rom ip 来实现各种功能的例子，没办法了，所以得自己重新思考对策。在看了好多基于 VGA 上用 rom ip 来实现的例子之后，我发现其实 HDMI 与 VGA 显示实际驱动电路都是一样的，因此就借鉴的一下米联客 demo 上的 HDMI 驱动电路的例子。<br>　　以下是关键的驱动行场同步的代码：  </p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">	reg[11:0]	x_cnt;</div><div class="line">	always @(posedge pix_clk)		//水平计数</div><div class="line">	begin</div><div class="line">		if(1&apos;b0)				x_cnt &lt;= 1;</div><div class="line">		else if(x_cnt==H_Total) x_cnt &lt;= 1;</div><div class="line">		else					x_cnt &lt;= x_cnt + 1;</div><div class="line">	end</div><div class="line">	</div><div class="line">	</div><div class="line">	</div><div class="line">	// 行有效区使能</div><div class="line">	reg	hsync_r;</div><div class="line">	reg	hs_de;</div><div class="line">	always @(posedge pix_clk)</div><div class="line">	begin</div><div class="line">		if(1&apos;b0) 			   hsync_r &lt;= 1&apos;b1;</div><div class="line">		else if(x_cnt==1) 	   hsync_r &lt;= 1&apos;b0;</div><div class="line">		else if(x_cnt==H_Sync) hsync_r &lt;= 1&apos;b1;</div><div class="line">		else ; </div><div class="line">		</div><div class="line">		if(1&apos;b0)                hs_de &lt;= 1&apos;b0;</div><div class="line">		else if(x_cnt==H_Start) hs_de &lt;= 1&apos;b1;</div><div class="line">		else if(x_cnt==H_End)   hs_de &lt;= 1&apos;b0;</div><div class="line">		else ;</div><div class="line">	end</div><div class="line">	</div><div class="line">	reg[11:0]	y_cnt;</div><div class="line">	always @(posedge pix_clk)</div><div class="line">	begin</div><div class="line">	 // 垂直计数，有两个条件判断，先判断 y 是否计数计满，再判断 x 计数满的情况下增加 y_cnt 的垂直计数</div><div class="line">		if(1&apos;b0) 				y_cnt &lt;= 1; </div><div class="line">		else if(y_cnt==V_Total) y_cnt &lt;= 1;</div><div class="line">		else if(x_cnt==H_Total) y_cnt &lt;= y_cnt + 1;</div><div class="line">		else ;</div><div class="line">	end</div><div class="line">	</div><div class="line">	</div><div class="line">	// 帧有效区使能</div><div class="line">	reg	vsync_r;</div><div class="line">	reg	vs_de;</div><div class="line">	always @(posedge pix_clk)</div><div class="line">	begin</div><div class="line">		if(1&apos;b0) 				vsync_r &lt;= 1&apos;b1;</div><div class="line">		else if(y_cnt==1)       vsync_r &lt;= 1&apos;b0;</div><div class="line">		else if(y_cnt==V_Sync)  vsync_r &lt;= 1&apos;b1;</div><div class="line">		else ;</div><div class="line">		</div><div class="line">		if(1&apos;b0)   				vs_de &lt;= 1&apos;b0;</div><div class="line">		else if(y_cnt==V_Start) vs_de &lt;= 1&apos;b1;</div><div class="line">		else if(y_cnt==V_End)   vs_de &lt;= 1&apos;b0;</div><div class="line">		else ;</div><div class="line">	end</div><div class="line">	```  </div><div class="line">###3. **rom 储存二进制文件显示**  　</div><div class="line">　　这是困扰我的最大的难题，在做这个图像显示的过程中，其实最难的就是这一部分。我将分两个方面说一下这个问题。</div><div class="line">#### 软件平台的搭建</div><div class="line">　　一开始我以为很简单来着，但花了差不多两三天的时间才理解了怎么构建 rom ip 这个问题。首先，这个 ip 是软件自带有的，不需要自己去写，这对于初学者来说，就省了很大的时间来学习这些东西，只要会用就好了，搭建好 ip 之后，再把它连进去就好。</div><div class="line">#### 图像转码为 rom ip 可用的格式</div><div class="line">　　这个的的话有相关的软件和教程，如果想学的话自己去百度一下应该是可以搜到的。</div><div class="line"></div><div class="line">　　回到最开始的问题，接下来是让图片通过 HDMI 显示出来。最开始图像显示是乱码，我以为是自己处理的图片有问题，再换了很多图片之后发现不是图片的问题，将答案锁定在行场行信号的同步问题上面，最后也如愿显示出来了！这个是最后显示的效果图：</div><div class="line"></div><div class="line">![](http://i.imgur.com/YuGhMHC.jpg)</div><div class="line"></div><div class="line">　　最后我贴下最后使图片完全显示的关键代码：</div></pre></td></tr></table></figure>

// 有效显示区坐标
wire[11:0] vga_xpos = x_cnt - H_Start;
wire[11:0] vga_ypos = y_cnt - V_Start;

//-----------------------------------------------------------------------------------------------
// 显示图像
reg [16:0]addr;
always @(posedge pix_clk)
begin
    if((vga_ypos&gt;=11&apos;d120) &amp;&amp; (vga_ypos&lt;=11&apos;d359) &amp;&amp; (vga_xpos&gt;=11&apos;d240) &amp;&amp; (vga_xpos&lt;=11&apos;d559)) // 320*240
        addr &lt;= (vga_ypos - 120)*320 + (vga_xpos - 240);
    else 
        addr &lt;= 0; 
end
</code></pre><p>```</p>
<p>　　完整的工程我已经放到我的 git(<a href="https://github.com/qingyi-wang/HDMI_DEMO_2017_03_28_01" target="_blank" rel="external">https://github.com/qingyi-wang/HDMI_DEMO_2017_03_28_01</a>) 上面，希望能对初学这个的同学有帮助。</p>
<h2 id="三-提高与改进"><a href="#三-提高与改进" class="headerlink" title="三.提高与改进"></a>三.提高与改进</h2><p>　　上面的图片有一些显示问题，经过仔细思考之后问题已经解决。</p>
<p>#####　1. 图片输出的粉红底问题已经解决，在像素赋值的时候加上条件判断即可。</p>
<p>#####　2. Display 驱动这部分单独写一个 ip 进行。</p>
<h2 id="四-总结及思考"><a href="#四-总结及思考" class="headerlink" title="四.总结及思考"></a>四.总结及思考</h2><p>　　以下几个方面是自己认为做的不好的方面，希望后续能够补充并进步。</p>
<p>#####　1. 程序写得太混乱，没有自己的条理和思路，对于整体的把握还有些欠缺。</p>
<p>#####　2. 没有遵循 DUT 的标准，导致在后面写 BINGO 大哥的 VGA 输出 demo 出现了显示问题，这个在有时间之后一定要把它给解决了。</p>
<p>#####　3. 心态不是很好，自己一定要注意不要想着事情一下子就能做好，而是要慢慢来的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　写在前面：耗时两周，终于算是搞定了第一个自己做的关于 HDMI 显示 rom 图片的小项目，过程艰辛（周围没有做这方面的同学），有好几次都想放弃，但最终还是坚持下来啦。啊哈哈，为自己点个赞。下面把我的经历写下来，希望对以后学习的同学有一些帮助。&lt;/p&gt;
&lt;h2 id=&quot;
    
    </summary>
    
    
      <category term="FPGA" scheme="http://yoursite.com/tags/FPGA/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/02/02/hello-world/"/>
    <id>http://yoursite.com/2017/02/02/hello-world/</id>
    <published>2017-02-02T15:38:23.733Z</published>
    <updated>2017-02-02T15:38:23.733Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
